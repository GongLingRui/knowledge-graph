你分享的这篇面经很详细，提到的几个问题也确实是大厂面试的高频考点。下面我针对这几个问题，结合你提供的资料和搜索到的信息，做一个系统的梳理和解答，希望能对你有所帮助。

### 💻 几个Java简单八股

虽然面经里没提具体问了什么，但根据你的链接和其他资料，“Java简单八股”通常指以下核心基础概念，可以提前准备好：

1.  **面向对象特征**：封装、继承、多态。要能说清楚它们的好处，比如**封装**可以隐藏实现细节、提高安全性；**继承**能复用代码；**多态**则通过父类引用指向子类对象，增强程序的灵活性。
2.  **`==` 和 `equals()` 区别**：
    *   `==`：对于基本类型，比较的是**值**；对于引用类型，比较的是**内存地址**。
    *   `equals()`：不能用于比较基本类型。它是一个方法，默认行为与`==`一样比较地址，但通常会被重写（如`String`、`Integer`），用来比较**对象的内容**是否相等。
3.  **`final` 关键字**：
    *   **修饰类**：类不能被继承（如`String`类）。
    *   **修饰方法**：方法不能被重写。
    *   **修饰变量**：变量变为常量，基本类型值不可变，引用类型**引用**不可变（但对象内部状态可变）。
4.  **`ArrayList` 和 `LinkedList` 的区别**：
    *   **数据结构**：`ArrayList`基于**动态数组**，`LinkedList`基于**双向链表**。
    *   **查询效率**：`ArrayList`支持**随机访问**，时间复杂度O(1)；`LinkedList`需要遍历，时间复杂度O(n)。
    *   **增删效率**：`LinkedList`在**头部或中间**插入/删除元素效率高（只需修改指针），O(1)；`ArrayList`在中间增删需要移动元素，O(n)。但在**尾部**增删，`ArrayList`效率也很高。
5.  **`HashMap` 的工作原理**：这是重中之重。可以简述为：底层是**数组+链表/红黑树**。put时，通过`hash`计算索引位置，如果该位置为空则直接放入，否则遍历链表/红黑树，如果找到相同key则覆盖，否则插入。当链表长度超过阈值（8）且数组长度>=64时，链表会转为红黑树以提升查询效率。它是**线程不安全**的。

### 🔒 MySQL事务隔离级别

MySQL的InnoDB引擎支持SQL标准定义的四种事务隔离级别，用于解决并发事务可能产生的**脏读**、**不可重复读**和**幻读**问题。隔离级别从低到高，并发性能依次降低。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| **READ UNCOMMITTED** (读未提交) | 可能 | 可能 | 可能 | 一个事务能读到另一个未提交事务修改的数据，**问题最多，基本不用**。 |
| **READ COMMITTED** (读已提交) | 不可能 | 可能 | 可能 | **Oracle等数据库的默认级别**。一个事务只能读到另一个已提交事务修改的数据，避免了脏读。 |
| **REPEATABLE READ** (可重复读) | 不可能 | 不可能 | 可能 **(InnoDB可避免)** | **MySQL的默认隔离级别**。保证在一个事务内多次读取同一数据的结果是一致的，避免了不可重复读。InnoDB通过**间隙锁（Gap Lock）** 机制，在这个级别下也**解决了幻读问题**。 |
| **SERIALIZABLE** (可串行化) | 不可能 | 不可能 | 不可能 | 最高级别，事务强制排序，强制加锁，**并发性能极差**，相当于串行执行。 |

### 💎 Redis + Lua脚本怎么防止超卖

**核心原理**：Redis是**单线程**模型，而Lua脚本在执行时是**原子性**的。这意味着整个脚本作为一个整体执行，执行过程中不会被其他客户端的命令插入，从而保证了“检查库存”和“扣减库存”这两个操作是连续的、不可分割的，避免了在高并发下因指令交错导致的库存扣超问题。

**简单示例脚本**：

```lua
-- KEYS[1]：商品库存的Redis键名，如 "product:1001:stock"
-- 返回值：>0 表示扣减成功并返回剩余库存； -1 表示库存不足

-- 1. 获取当前库存
local currentStock = tonumber(redis.call('get', KEYS[1]) or "0")

-- 2. 检查库存是否充足
if currentStock > 0 then
    -- 3. 库存减1
    redis.call('decr', KEYS[1])
    -- 4. 返回扣减前的库存（或者返回1表示成功）
    return currentStock - 1
else
    -- 5. 库存不足，返回-1
    return -1
end
```

**执行流程**：
1.  **预先加载脚本**：将Lua脚本加载到Redis服务器，得到一个SHA值。或者每次直接发送脚本。
2.  **调用脚本**：Java后端在接收到秒杀请求时，执行`redis.eval()`或`evalsha()`，将商品库存的Key（如`product:1001:stock`）作为参数传递给脚本。
3.  **原子执行**：Redis服务器原子地运行脚本，根据返回值判断是否扣减成功（返回`-1`为失败，返回非负数为成功）。
4.  **后续操作**：如果脚本返回成功，后端才继续执行创建订单等数据库操作；如果失败，则直接返回“已售罄”。

### 📨 讲讲消息队列

消息队列（Message Queue，MQ）是一种用于分布式系统间通信的中间件，其核心价值在于**解耦、异步、削峰填谷**。

**1. 核心作用**
*   **解耦**：系统A无需关心谁需要使用它的数据，只需将消息发给MQ，依赖它的系统B、C自己去订阅即可。这样，即使B系统宕机或升级，也不会影响A系统的核心流程。
*   **异步**：原本一个需要同步调用的长流程（如用户下单后需要发短信、送积分），可以通过MQ异步处理，快速响应用户“下单成功”，从而提升系统响应速度。
*   **削峰填谷**：面对突发流量（如秒杀），系统后端可能扛不住。MQ可以像一个大坝，将海量请求暂存在队列中，然后让后端服务按照自己的处理能力（如每秒1000个）去慢慢消费，保护后端系统不被冲垮。

**2. 常见问题与方案**
面试官问MQ，通常会紧接着问如何保证消息的可靠性，所以这几个问题也需要准备好：
*   **如何保证消息不丢失？** 这是一个经典问题，需要从三个环节保证：
    1.  **生产者**：确认消息成功发送到Broker（使用`confirm`机制）。
    2.  **MQ本身**：开启持久化，将消息刷盘。
    3.  **消费者**：关闭自动`ACK`，改为手动确认，确保业务处理成功后才告知MQ删除消息。
*   **如何保证消息不被重复消费（幂等性）？** 因为网络原因，生产者或MQ可能重传消息。消费者需要保证处理一次和多次的结果一致。常见方案是：在消费端利用数据库的**唯一键约束**（如订单号）或使用Redis记录已处理的**消息ID**来去重。
*   **如何保证消息的顺序性？** 有些业务需要消息按顺序处理（如：创建订单、支付订单、取消订单）。解决方案是：将需要保证顺序的**消息发送到同一个Queue中**，并且**只用一个消费者**去消费这个Queue。

### ✍️ 算法题：分割回文串 II (LeetCode 132)

你当时想到用动态规划来解是完全正确的方向，而且这道题的最优解就是动态规划。回溯法虽然理论上可行，但在字符串较长时（题目给的长度可达2000）很容易超时。你没有通过可能是因为动态规划的状态定义或转移方程没有完全理清。这道题其实是LeetCode上的一道原题 **“132. 分割回文串 II”**。

**解题思路**：需要使用**两次动态规划**。

1.  **第一次DP：预处理回文子串**
    我们需要一个二维布尔数组 `isPal[i][j]`，表示字符串从下标 `i` 到 `j` 的这个子串是否是回文串。计算方式如下：
    *   单个字符 `i == j`，肯定是回文。
    *   两个字符 `j - i == 1`，如果 `s[i] == s[j]` 则是回文。
    *   长度大于2时，如果 `s[i] == s[j]` 并且 `isPal[i+1][j-1]` 是回文，那么 `isPal[i][j]` 也是回文。

2.  **第二次DP：计算最少分割次数**
    定义 `dp[i]` 为**以第 `i` 个字符结尾的子串 `s[0...i]` 的最少分割次数**。
    *   **初始化**：`dp[i] = i`，表示最坏情况下，把每个字符都切出来（需要切 `i` 刀）。
    *   **状态转移**：我们遍历所有可能的分割点 `j` (`0 <= j < i`)。
        如果 `s[j+1...i]` 是回文子串（即 `isPal[j+1][i] == true`），那么我们就可以在 `j` 这个地方切一刀，将 `s[0...i]` 分成 `s[0...j]` 和 `s[j+1...i]` 两部分。由于 `s[j+1...i]` 已经是回文，不需要再切，所以总的切割次数就是 `dp[j] + 1`。
        我们需要在所有可能的 `j` 中取最小值：`dp[i] = min(dp[i], dp[j] + 1)`。
        此外，如果整个 `s[0...i]` 本身就是一个回文串（`isPal[0][i] == true`），那么 `dp[i] = 0`。

**参考代码 (Java)**：

```java
class Solution {
    public int minCut(String s) {
        int n = s.length();
        if (n == 0) return 0;

        // 1. 预处理，isPal[i][j] 表示 s[i..j] 是否是回文
        boolean[][] isPal = new boolean[n][n];
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s.charAt(i) == s.charAt(j) && (j - i <= 1 || isPal[i + 1][j - 1])) {
                    isPal[i][j] = true;
                }
            }
        }

        // 2. 动态规划计算最少分割次数
        int[] dp = new int[n];
        for (int i = 0; i < n; i++) {
            dp[i] = i; // 初始化：最多切 i 刀
            if (isPal[0][i]) {
                dp[i] = 0; // 本身就是回文，不需要切
                continue;
            }
            for (int j = 0; j < i; j++) {
                if (isPal[j + 1][i]) {
                    dp[i] = Math.min(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[n - 1];
    }
}
```

面试遇到问题别气馁，及时复盘把知识点和题目吃透，下次一定能做得更好。祝你后续的面试顺利！
